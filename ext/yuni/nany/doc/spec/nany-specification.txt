

The Nany Language
=================


Introduction
------------

Nany (/na.ni/) is meant to be a modern language, created for fast,
safe, efficient programming in multi-threaded distributed
environments. It is a very high-level language which offers various
features to help you write programs :
* Object orientation
* Type inference
* Garbage collection
* Comprehension lists
* Parallel and event-driven programming
* Closures
* Live Distributed Objects
* Workflows
* Duck typing through static constraints
* Contracts through dynamic constraints
* Generics
* Predicates
* Heterogeneous containers through implicit inheritance
* Support for Doxygen comments
This list is non-exhaustive.

### Hello, World !

It is traditional to offer a "Hello, World !" program to demonstrate
the overall syntax flavour of the language. Here it is in Nany :

    program HelloWorld;
    
    function main
    {
        io.out << "Hello, World !" << io.endl;
    }

As you can see, it is very concise, and does not require a class to
encapsulate the main function (as is the case in Java and C#). Also,
you can see that the function's return type is inferred.


Basics
------

### Comments

Nany allows for several types of comments and several syntaxes for
each type.

#### In-line comments

In-line comments can be written either with `#` or with `//` :

    doSomething(a, b); // This will call the doSomething function on a and b
    doNothing;         # This does not do much actually

#### Multi-line comments

Multi-line comments can be written either with `#* *#` or with `/* */` :

    doSomething; /* This is a multi-line
    comment that can spread
    quite far */ doSomethingElse; #* This is another
    comment *#

#### Doxygen comments

It is possible to write Doxygen-style comments for automatic code
documentation :

    #*!
    ** \brief Get the length of an object
    *#
    function length(s): uint
    {
        return s.length
    }
    
    /*!
    ** \brief Get the number of items in a container
    */
    function count(c): uint
    {
        return c.count
    }

### Variables

The syntax for variable declaration is as follows :

    <identifier> : <type> := <expression> ;

Variable declaration in Nany requires initialization. If there is no
initialization, the default value for the specified type will be used.
Since types are inferred, it is not mandatory to specify the type.
However, it is not allowed to write neither the type nor the
initialization, since the identifier would then have no understandable
type.

Some examples of variable declaration :

    program VariableDeclarations;
    
    class A
    {
        class method create
        {}
    }
    
    function main
    {
        var i := 0;           // integer
        var j := 42u;         // unsigned integer
        var s : string;       // string, will be initialized to ""
        var a: A := A.create; // class A
        var aa: A;            // class A, will be initialized to nil
        b                 // ERROR : unknown identifier
    }

### Functions

In Nany, it is not possible to declare a function without defining it
(there is no forward declaration). The full syntax for defining a
function is as follows :

    <qualifier> function <identifier>(<identifier>: <type>, <identifier>: <type>, ...): <type>
    {
        <expression>
    }

Since types are inferred, all types in the declaration are optional.
Also, in Nany, parentheses are optional on function declarations and
function calls if there is no argument. For example :

    program Test;
    
    function doSomething
    {
        // snip
    }
    
    function main
    {
        doSomething;
        return 0
    }

Following these principles, these two functions are exactly
equivalent :

    function main { return 0 }

    function main() : int { return 0 }


Classes
-------

Since Nany offers object orientation, there are classes. This is the
syntax for class definitions :

    class <identifier>
    {
    }

Note for C++ developers :
No `;` (semi-colon) required after the `}` (right curly brace).


### Attributes

The syntax for class attributes is similar to simple variable
definitions, but you need to specify the `attribute` keyword :

    class <identifier>
    {
        <qualifier> attribute <identifier> : <type> := <expression> ;
    }

Once again, you need to provide either typing or an initialization
value.


### Methods

The syntax for class methods uses a `method` keyword similarly to the
way functions are defined :

    class <identifier>
    {
        <qualifier> method <identifier> (<identifier> : <type>, <identifier> : <type>, ...) : <type>
        {
            // Method body here
        }
    }

Just as functions can not be forward-declared, methods must be
defined directly in the class, as it is done in Java or C#. It is up
to the tools to extract a clean public interface for external use.


### Constructors and destructors

There is no particular syntax for construction and destruction of
objects. Constructors and destructors are defined using reserved
method names. All the following are reserved :

    class A
    {
        // Standard constructor
        method create {}
        // Copy constructor
        method clone {}
        // Destructor
        method destroy {}
    }


### Visibility

There are four visibilities available inside classes :
* `published` : `public` and accessible in the tools' interface designer
* `public` : Accessible by any code that uses the containing module
* `protected` : Accessible by the class itself and its inheritors
* `private` : Only accessible by the class itself

__Default visibility for classes, methods and attributes is `public`__

Syntax for visibility in classes is as follows :

    published class A
    {
    public
        method myPublicMethod
        {
            return myPrivateString.length + myPrivateInt
        }
    
    private
        myPrivateInt := 0;
        myPrivateString := "";
    }


### Operator overloading

It is possible to overload most operators using the `operator` keyword.

    class MyInteger
    {
    public
        operator + (x)
        {
            return pValue + x
        }

        operator * (x)
        {
            return pValue * x
        }

    private
        pValue: int;
    }

It is not possible to overload the `()` (parentheses) operator.
The `[]` (brackets) operator can be overloaded as follows :

    class MyStringArray
    {
        // Get
        operator [i] { return data[i] }
        operator [i, j] { return data[i + j] }
        // Set
        operator [i] (v) { data[i] := v }
        operator [i, j] (v) { data[i + j] := v }

    private
        data := new string[1024];
    }

As shown above, it is possible to give a list of keys to operator[].


### Self

The `self` keyword is the equivalent of `this` in major OO languages
(C++, Java, C#, ...). Inside any instance method, `self` is a reference
to the current object. An interesting trick is to use `typeof self` to
get the exact type of the current object. This comes very handy to write
type constraints for example.


### Reflection

In Nany, all objects have a preexisting set of methods, among which
all the reflection features are provided. This reflection is meant to be
very easy to use, and _safe_.

Provided reflection methods follow :

* method hasMethod(string methodName): bool
* method hasMethod(string methodName, Type functionType): bool
* method getMethod(string methodName): Any
* method getMethod(string methodName, Type functionType): any
* method getMethodType(string methodName): Type
* method hasAttribute(string attributeName): bool
* method hasAttribute(string attributeName, Type attributeType): bool
* method getAttribute(string attributeName): any
* method getAttributeType(string attributeName): Type


### Class genericity

Nany offers genericity in classes. This is one of the tools allowing
for meta-programming. Type inference, constraints and specializations
also cater to many meta-programming needs (see related chapters).

The syntax is a lot like C# generics :

    class Pair<:K, V:>
    {
    public
        method create(k, v)
        {
            key := k;
            value := v
        }
    
    private
        var key: K;
        var value: V;
    }

To apply explicit constraints on generic types, see the specific
chapter on type constraints.


### Sample

This sample class illustrates what a class would look like in Nany :

    /*!
    ** \brief Naive vector implementation
    */
    class Vector<:T:>
    {
    public
        const method get(i)
        {
            return pData[i]
        }
        
        method set(i, value)
        {
            pData[pSize++] := value
        }
        
        operator [i](value)
        {
            set(i, value)
        }
        
        const operator [i]
        {
            return get(i)
        }
        
        method add(value)
        {
            pData[i] += value
        }
        
        const method size
        {
            return pSize
        }
        
    private
        var MaxSize : const := 65535u;
        var pData := new T[MaxSize];
        var pSize := 0u;
    }


Expressions
-----------

In Nany, many things are expressions. There is no actual statement
that is not an expression. Possible expressions in Nany are as
follows.

### Literals

* <integer literal>
* <real literal>
* <string literal>
* <boolean literal>
* <nil>

### Structured types

* <expression> . <identifier>
* <identifier> [ <expression> ]
* (<expression>, <expression>, ...)
* [<expression>..<expression>]
* [<expression> => <expression>, <expression> => <expression>, ...]

### Function calls

* <identifier>
* <expression> ( <expression> , <expression>, ...)

### Operators

* - <expression>
* -- <expression>
* ++ <expression>
* <expression> --
* <expression> ++
* <expression> + <expression>
* <expression> - <expression>
* <expression> * <expression>
* <expression> / <expression>
* <expression> % <expression>
* <expression> < <expression>
* <expression> > <expression>
* <expression> <= <expression>
* <expression> >= <expression>
* ! <expression>
* not <expression>
* <expression> = <expression>
* <expression> != <expression>
* <expression> or <expression>
* <expression> and <expression>
* <expression> xor <expression>
* <expression> | <expression>
* <expression> ~ <expression>
* <identifier> __in__ <expression>
* __in__ <expression>
* <expression> __on__ <expression>
* <expression> __is__ <expression>
* <expression> __as__ <expression>
* & <expression>

### Assignment

Assignments are void expressions.

* <expression> := <expression>

### Allocation

* new <expression>
* new <expression> ( <expression> , <expression> , ... )
* new <expression> [ <expression> ]
* new <expression> [ <expression> ] ( <expression> )
n := new bool[count];
foreach i in n do i := false
"string".size

### Multiple expressions

* <expression> ; <expression>
* <expression> ; <expression> ;
* { }
* { <expression> }

### Conditionals

* __if__ <expression> __then__ <expression>
* __if__ <expression> __then__ <expression> else <expression>

### Loops

Loops are void expressions.

* __for__ <expression>, __order__ <expression> __asc__, step
  <expression> __do__ <expression>
* __while__ <expression> __do__ <expression>
* __do__ <expression> __while__ <expression>


Typing
------

### Built-in types

Nany offers several built-in types :
* uint
* uint8
* uint16
* uint32
* uint64
* uint128
* int
* int8
* int16
* int32
* int64
* int128
* float
* double
* double128
* bool
* any
* uuid
* Type

`any` represents any one type. Depending on circumstances, the
corresponding type may be known at compile time or not.

`Type` is a specific type that represents a type. Type objects can
be manipulated and compared easily.

### Type manipulation

#### typeof

    typeof(<expression>)

The `typeof` function evaluates the type of an expression and
returns an object of type `Type`.

#### is

    <expression> is <type>

The `is` binary operator evaluates whether the left-hand operand
has or inherits a given type. It will return a boolean with the
answer.

#### as

    <expression> as <type>

The `as` binary operator tries to cast the left-hand operand into
the right-hand operand (which must be a type). If the cast fails,
it returns `nil`;

#### Combining it all

    function foo(s, t)
    {
        var s := getValue;
        var t := getOtherValue;
        if s is typeof(t) then
	       return s as typeof(t);
		return nil
    }


### Type inference and overloading

Nany uses type inference, which means explicit typing of variables,
function parameters, and function return types is optional. Type
inference forbids overload with the same number of parameters. For
example :

    public function foo(i) { io.out << "i: " << i; }
    
    public function foo(s: string) { system.io.println(s); }

would generate a compile error, because a call to `foo` with a
string argument would be ambiguous.

If the number of arguments is different, the call is not ambiguous
and the program is valid :

    public function foo(i) { io.out << i; i }
    
    public function foo(i, j) { io.out << i << ' ' << j; j }

Considering the following :

    public function foo(i: int) { io.out << i }
    
    public function foo(s: string) { io.out << s; }

it would seem that the call is not ambiguous, since both types were
explicitly given. However, Nany does not allow this, and offers a
different way to express the same idea using specializations (see
function specializations).


### Type constraints

It is possible to provide explicit and implicit constraints on types,
which will be evaluated statically when possible, dynamically when
not.

Duck typing example (implicit constraint on type) :

    public function foo(a): int
    {
        a.bar(42)
    }

Implicitly, this code requires that variable `a` be of a type that
defines a method with the following prototype :

    public method bar(x: int): int

Conversely, it is possible to specify the constraint explicitly :

    public function foo(a): int
    in
        a.reflect.method(bar) is (function(int): int));
    {
        a.bar(42)
    }

The two samples are almost equivalent (there is a slight difference
in that the explicit constraint does not allow automatic conversions).

The constraint will be evaluated statically (at compile time) on all
calls where the type of `a` is known at compile time. If the constraint
is violated, the compiler will produce an error.

If the type of `a` is not known at compile time, the constraint will be
evaluated dynamically (during execution). If the constraint is
violated, the program will throw an exception (this is the default,
but the behaviour can be modified).

__Compiler implementation tip: we advise to implement duck typing
using hidden constraints for coherency. For example, if the developer
wrote the first sample, the compiler would automatically generate the
constraint from the second sample.__


Meta-programming
----------------

Meta-programming is a very powerful way to write reusable code and
express high-level ideas with little code redundancy. Nany offers
several features to help you write meta-code.

### Function specializations

Many languages offer overloading for functions, which means several
prototypes may be provided for the same function or method name.
However, languages with type inference often do not provide
overloading in order to avoid problems such as the following :

    // `param1`'s type is inferred. There is a constraint regarding `operator <<`
    function foo(param1) { io.out << param1; }
    
    // `param2`'s type is integer.
    function foo(param2: int) { io.out << "Integer : " << param1; }
    
    function main
    {
        // Call `foo` with an integer argument
        foo(23)
    }

In this example, it might not be clear to the compiler which of the
two prototypes to call. In Nany, however, this is valid, and the
compiler will apply pattern-matching to the argument to find the best
match for the provided type. This is similar to the way C++ templates
are resolved by the compiler :

    // Class template
    template<class T>
    class A
    {
    public:
        enum { Specialized = 0 };
    };
    
    // Class template specialization
    template<>
    class A<int>
    {
    public:
        enum { Specialized = 1 };
    };
    
    int main()
    {
        // Instanciate the specialized version of A
        return A<int>::Specialized;
    }

The ordering rules for the matching are also similar to C++ templates,
in decreasing order of priority:
* Exact type
* Parent type
* Type with available conversion
* Most constrained type
* Least constrained type
If several conversions with the same priority are available, the
compiler will generate an ambiguous call error.

A main difference with C++ templates is that Nany specializations are
simply written with an overloading syntax, and the compiler will
automatically apply pattern-matching when needed. Also, C++ does not
provide partial template specialization on class methods, whereas
Nany applies pattern-matching on function prototypes, method
prototypes, and class generic parameters.
